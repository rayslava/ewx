This is intended to be a hack for emacs conf 22.
Have fun ;)
Don't overengineer; wait for feedback first.

* Experimentar -> Demo?

? Suitable base:

ref/
  wlroots
  cage
  mahogany
  river

tinywl & cage use wlr_scene
mahogany is split into a c backend and a cl frontend
river has a seperate program that specifies layout
  but both don't use the newer wlr_scene api for damage-tracking

https://www.hjdskes.nl/projects/cage/
  Cage is based on the annotated source of tinywl and rootston.

-> tinywl

** tinywl
[[http://inclem.net/2021/04/17/wayland/writing_a_wayland_compositor_with_wlroots/][Writing a wayland compositor with wlroots]]
  Fork tinywl. This tiny example is shipped with wlroots and is an
  excellent base for a serious compositor. Although short it implements
  in a basic way almost every core functionality youâ€™ll need, and
  implicitly teaches a lot about Wayland API interaction (especially if
  using the C interface to events, listeners etc.) which scales very
  well when branching out into other protocols. Since tinywl is within
  the wlroots tree it is also guaranteed to be up to date.


tinywl main walktrought:
main does setup

[[file:ref/wlroots/tinywl/tinywl.c::/* Create a scene graph. This is a wlroots abstraction that handles all][tinywl.c]]:
  Create a scene graph. This is a wlroots abstraction that handles all
  rendering and damage tracking. *All the compositor author needs to do*
  *is add things that should be rendered to the scene graph at the proper*
  *positions and then call wlr_scene_output_commit() to render a frame if*
  *necessary.*
  
Afterwards main sets
  setenv("WAYLAND_DISPLAY", socket, true);
forks and runs the startup_cmd in the child

[[file:ref/wlroots/tinywl/tinywl.c::/* Run the Wayland event loop. This does not return until you exit the][In the parent the event loop is started]]
  Run the Wayland event loop. This *does not return until you exit the*
  *compositor*. Starting the backend rigged up all of the necessary event
  loop configuration to listen to libinput events, DRM events, generate
  frame events at the refresh rate, and so on. */


Notable omissions from TinyWL:
- HiDPI support
- Any kind of configuration, e.g. output layout
- Any protocol other than xdg-shell (e.g. layer-shell, for
  panels/taskbars/etc; or Xwayland, for proxied X11 windows)
- Optional protocols, e.g. screen capture, primary selection, virtual
  keyboard, etc. Most of these are plug-and-play with wlroots, but they're
  omitted for brevity.

** wlr_scene
[[file:ref/wlroots/include/wlr/types/wlr_scene.h::The scene-graph API provides a declarative way to display surfaces. The][wlr_scene]]:
  The scene-graph API provides a declarative way to display surfaces. The
  compositor creates a scene, adds surfaces, then renders the scene on
  outputs.
 
  The scene-graph API only supports basic 2D composition operations (like the
  KMS API or the Wayland protocol does). For anything more complicated,
  compositors need to implement custom rendering logic.

Set the position of the node relative to its parent.
  wlr_scene_node_set_position

** [X] Build tinywl (->  ewl?)
CLOSED: [2022-10-11 Tue 22:38]

guix shell wlroots wayland-protocols gcc-toolchain make pkg-config -- make CC=gcc

guix shell --manifest=manifest.scm -- make CC=gcc
guix shell --manifest=../../../manifest.scm -- make CC=gcc

** [ ] 1st protoype
[2022-10-14 Fri]
Scope: *Just windows for now! No input handling in emacs.*

4 components:

1. A wayland compositor (wayland-server) that wraps emacs and talks to : *Server*   in C
2. a wayland-client as dynamic module that responds to the compositor. : *Client*   in C
3. A wayland protocol for this communication.                          : *Protocol* in XML
4. A elisp library that does the window management.                    : *Lib*      in ELisp 

Flow:
/A new window/shell(surface) is created./
#     emacs / wayland
- Server reacts to events.new_surface -> Creates datastructures but does not show the window
- instead it sends event to client. The event contains info about the new window (title, ...)
- Client translates window info to elisp
- Emacs lib manages the window. It records and positions the window
- a show requests is send to server if window is visible
- The server shows the window as requested

?
- How does emacs recieve event?


Protocol:
- Events :: new, destroy
- Requests :: show (position), destroy

other: fullscreen

open questions: how to handle embedded -> later!

*** Drive from emacs
Emacs is the "server" (actually a client talking to the server, X style).
Emacs is the server side decoration.

An idea in design space:
  C server is minimal.
  + Do more in elisp
  - Slower and single threaded

  eg. if it wants to create window it has to ask emacs first 
      emacs than positions the window and ews draws it.

  -> A client wants a new toplevel window
  -> Emacs creats it's decorations frame & waits for the event & positions both inside parent (window/frame/monitor)

  Emacs does moving of windows; eg move by dragging modeline

  *Unification*
  # This approad seems simpler with less duplication between C & Lisp.

*** LOG
start
  New toplevel XDG surface app_id=emacs title=emacs@muh
emacs new frame
  New toplevel XDG surface app_id=emacs title=emacs@muh
eshell mpv
  New toplevel XDG surface app_id=mpv title=10_Blues_Shuffle_EASY_.mp4

---

start
  00:00:00.425 [ews.c:765] New toplevel XDG surface app_id=emacs title=emacs@muh pid=15343
new frame
  00:02:23.492 [ews.c:765] New toplevel XDG surface app_id=emacs title=emacs@muh pid=15343
mpv
  00:03:54.271 [ews.c:765] New toplevel XDG surface app_id=mpv title=10_Blues_Shuffle_EASY_.mp4 - mpv pid=15392
second emacs
  00:07:23.856 [ews.c:765] New toplevel XDG surface app_id=emacs title=emacs@muh pid=15456
new frame in second emacs
  00:07:42.647 [ews.c:765] New toplevel XDG surface app_id=emacs title=emacs@muh pid=15456

Wayland only?

** Layers
[2022-10-14 Fri]
3 layers
1. emacs frame
2. embedded windows (inside buffers)
3. floating windows

floating: only position from elisp for now?
  usecase floating webcam for talk

** Keyboard
[2022-10-14 Fri]

Normally give all keys to focused window. 
But also some way to say from emacs: Give these keys to emacs.
And simulated keys over protocol.
Maybe keytranslation | interception tools style?

* Webcam & mpv
[2022-10-14 Fri]
mpv --profile=low-latency --untimed /dev/video0
